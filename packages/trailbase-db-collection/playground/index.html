<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TrailBase Collection Playground</title>
  <style>
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --primary: #0f3460;
      --accent: #e94560;
      --success: #4ade80;
      --warning: #fbbf24;
      --error: #ef4444;
      --text: #e2e8f0;
      --text-muted: #94a3b8;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--primary);
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .subtitle {
      color: var(--text-muted);
    }

    .status-bar {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 15px;
      flex-wrap: wrap;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: var(--surface);
      border-radius: 8px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .status-dot.connected { background: var(--success); }
    .status-dot.error { background: var(--error); }
    .status-dot.loading { background: var(--warning); animation: pulse 1s infinite; }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .config-section {
      background: var(--surface);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .config-row {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    label {
      font-weight: 500;
    }

    input[type="text"] {
      padding: 10px 15px;
      border: 1px solid var(--primary);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
      min-width: 300px;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:hover {
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-secondary {
      background: var(--primary);
      color: var(--text);
    }

    .btn-success {
      background: var(--success);
      color: #000;
    }

    .tests-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .test-card {
      background: var(--surface);
      border-radius: 12px;
      overflow: hidden;
    }

    .test-header {
      padding: 15px 20px;
      background: var(--primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 15px;
    }

    .test-title {
      font-size: 14px;
      font-weight: 600;
    }

    .test-badge {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .test-badge.failing {
      background: var(--error);
      color: white;
    }

    .test-badge.passing {
      background: var(--success);
      color: #000;
    }

    .test-body {
      padding: 20px;
    }

    .test-description {
      color: var(--text-muted);
      font-size: 13px;
      margin-bottom: 15px;
    }

    .test-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    .test-output {
      background: var(--bg);
      border-radius: 8px;
      padding: 15px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .test-output.success {
      border-left: 3px solid var(--success);
    }

    .test-output.error {
      border-left: 3px solid var(--error);
    }

    .test-output.running {
      border-left: 3px solid var(--warning);
    }

    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 10px;
    }

    .data-table th,
    .data-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid var(--primary);
    }

    .data-table th {
      background: var(--primary);
      font-weight: 600;
    }

    .data-table tr:hover td {
      background: rgba(255,255,255,0.05);
    }

    .log-entry {
      margin: 2px 0;
    }

    .log-entry.info { color: var(--text); }
    .log-entry.success { color: var(--success); }
    .log-entry.error { color: var(--error); }
    .log-entry.warn { color: var(--warning); }

    .section-title {
      font-size: 1.2rem;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--primary);
    }

    .data-stats {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .stat-box {
      background: var(--bg);
      padding: 15px 20px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--accent);
    }

    .stat-label {
      font-size: 12px;
      color: var(--text-muted);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>TrailBase Collection Playground</h1>
      <p class="subtitle">Interactive testing for TrailBase e2e scenarios</p>
      <div class="status-bar">
        <div class="status-item">
          <div class="status-dot" id="connectionStatus"></div>
          <span id="connectionText">Not connected</span>
        </div>
        <div class="status-item">
          <div class="status-dot" id="dataStatus"></div>
          <span id="dataText">No data</span>
        </div>
      </div>
    </header>

    <div class="config-section">
      <div class="config-row">
        <label for="serverUrl">TrailBase Server:</label>
        <input type="text" id="serverUrl" value="http://localhost:4000" placeholder="http://localhost:4000">
        <button class="btn-primary" id="connectBtn" onclick="connect()">Connect</button>
        <button class="btn-secondary" id="seedBtn" onclick="seedData()" disabled>Seed Data</button>
        <button class="btn-secondary" id="clearBtn" onclick="clearData()" disabled>Clear Data</button>
      </div>
      <div class="data-stats" id="dataStats" style="display:none;">
        <div class="stat-box">
          <div class="stat-value" id="usersCount">0</div>
          <div class="stat-label">Users</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="postsCount">0</div>
          <div class="stat-label">Posts</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="commentsCount">0</div>
          <div class="stat-label">Comments</div>
        </div>
      </div>
    </div>

    <h2 class="section-title">Failing Tests (Pass individually, fail in suite)</h2>

    <div class="tests-grid">
      <!-- Test 1: Multi-column orderBy subsequent pages -->
      <div class="test-card">
        <div class="test-header">
          <span class="test-title">Multi-column orderBy: Subsequent Pages</span>
          <span class="test-badge failing">Failing in Suite</span>
        </div>
        <div class="test-body">
          <p class="test-description">
            Creates two queries with the same orderBy (isActive desc, age asc) but different limits (15 and 30).
            Verifies the first 15 items are identical in both results.
          </p>
          <div class="test-actions">
            <button class="btn-primary" onclick="runTest1()">Run Test</button>
            <button class="btn-secondary" onclick="clearOutput('test1')">Clear</button>
          </div>
          <div class="test-output" id="test1Output">Click "Run Test" to execute...</div>
        </div>
      </div>

      <!-- Test 2: Mixed direction orderBy -->
      <div class="test-card">
        <div class="test-header">
          <span class="test-title">Multi-column orderBy: Mixed Directions</span>
          <span class="test-badge failing">Failing in Suite</span>
        </div>
        <div class="test-body">
          <p class="test-description">
            Queries posts with orderBy(userId asc, viewCount desc) and limit 20.
            Verifies ordering is correct: userId ascending, then viewCount descending within same userId.
          </p>
          <div class="test-actions">
            <button class="btn-primary" onclick="runTest2()">Run Test</button>
            <button class="btn-secondary" onclick="clearOutput('test2')">Clear</button>
          </div>
          <div class="test-output" id="test2Output">Click "Run Test" to execute...</div>
        </div>
      </div>

      <!-- Test 3: setWindow with mixed direction -->
      <div class="test-card">
        <div class="test-header">
          <span class="test-title">setWindow: Mixed Direction OrderBy</span>
          <span class="test-badge failing">Failing in Suite</span>
        </div>
        <div class="test-body">
          <p class="test-description">
            Creates a query on posts with mixed direction orderBy, then uses setWindow to page.
            Verifies second page maintains correct ordering.
          </p>
          <div class="test-actions">
            <button class="btn-primary" onclick="runTest3()">Run Test</button>
            <button class="btn-secondary" onclick="clearOutput('test3')">Clear</button>
          </div>
          <div class="test-output" id="test3Output">Click "Run Test" to execute...</div>
        </div>
      </div>

      <!-- Test 4: Insert appearing in matching queries -->
      <div class="test-card">
        <div class="test-header">
          <span class="test-title">Mutations: Insert Appearing in Query</span>
          <span class="test-badge failing">Failing in Suite</span>
        </div>
        <div class="test-body">
          <p class="test-description">
            Creates a query filtering users by age, inserts a new user matching the predicate,
            and verifies the new user appears in the query results via subscription.
          </p>
          <div class="test-actions">
            <button class="btn-primary" onclick="runTest4()">Run Test</button>
            <button class="btn-secondary" onclick="clearOutput('test4')">Clear</button>
          </div>
          <div class="test-output" id="test4Output">Click "Run Test" to execute...</div>
        </div>
      </div>
    </div>

    <h2 class="section-title" style="margin-top: 30px;">All Tests</h2>
    <div class="config-section">
      <button class="btn-success" onclick="runAllTests()">Run All Failing Tests</button>
      <span style="margin-left: 15px; color: var(--text-muted);">
        Runs all 4 failing test scenarios sequentially
      </span>
    </div>
  </div>

  <!-- TrailBase Client -->
  <script type="module">
    // Import TrailBase client (you may need to adjust based on your bundler setup)
    // For now, we'll implement a minimal client inline

    let client = null;
    let usersApi = null;
    let postsApi = null;
    let commentsApi = null;

    // Store seed data for reference
    let seedDataCache = null;

    // UUID generation matching the test suite
    function generateId(prefix, index) {
      const hex = index.toString(16).padStart(8, '0');
      return `${hex.slice(0, 8)}-0000-4000-8000-${hex.padStart(12, '0')}`;
    }

    // Base64 encoding for TrailBase BLOB UUIDs
    function uuidToBase64(uuid) {
      const hex = uuid.replace(/-/g, '');
      const bytes = new Uint8Array(16);
      for (let i = 0; i < 16; i++) {
        bytes[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
      }
      let binaryString = '';
      for (const byte of bytes) {
        binaryString += String.fromCharCode(byte);
      }
      return btoa(binaryString).replace(/\+/g, '-').replace(/\//g, '_');
    }

    function base64ToUuid(base64) {
      try {
        const standardBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');
        const padded = standardBase64 + '=='.slice(0, (4 - standardBase64.length % 4) % 4);
        const binaryString = atob(padded);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20, 32)}`;
      } catch {
        return base64;
      }
    }

    // Minimal TrailBase REST client
    class TrailBaseClient {
      constructor(baseUrl) {
        this.baseUrl = baseUrl.replace(/\/$/, '');
      }

      async list(table, options = {}) {
        const params = new URLSearchParams();
        if (options.limit) params.set('limit', options.limit);
        if (options.offset) params.set('offset', options.offset);

        const url = `${this.baseUrl}/api/records/v1/${table}?${params}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error(`Failed to list ${table}: ${response.status}`);
        return response.json();
      }

      async create(table, data) {
        const url = `${this.baseUrl}/api/records/v1/${table}`;
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Failed to create in ${table}: ${response.status} - ${text}`);
        }
        return response.json();
      }

      async delete(table, id) {
        const url = `${this.baseUrl}/api/records/v1/${table}/${id}`;
        const response = await fetch(url, { method: 'DELETE' });
        if (!response.ok) throw new Error(`Failed to delete from ${table}: ${response.status}`);
        return true;
      }

      async health() {
        const response = await fetch(`${this.baseUrl}/api/healthcheck`);
        return response.ok;
      }
    }

    // Generate seed data matching the test suite
    function generateSeedData() {
      const users = [];
      const posts = [];
      const comments = [];
      const now = new Date();
      const oneDay = 24 * 60 * 60 * 1000;
      const oneYear = 365 * oneDay;

      const names = [
        'Alice', 'bob', 'Charlie', 'DIANA', 'Eve', 'Frank', 'Grace', 'henry',
        'Ivy', 'Jack', 'Kate', 'liam', 'Mia', 'Noah', 'Olivia', 'PAUL',
        'Quinn', 'Rose', 'sam', 'Tina'
      ];

      // Generate 100 users
      for (let i = 0; i < 100; i++) {
        const id = generateId('user', i);
        users.push({
          id,
          name: `${names[i % names.length]} ${i}`,
          email: i % 10 < 7 ? `user${i}@example.com` : null,
          age: i === 0 ? 0 : i === 1 ? -5 : i === 2 ? 150 : 18 + (i % 63),
          isActive: i % 5 !== 0,
          createdAt: new Date(now.getTime() - Math.random() * oneYear),
          metadata: i % 5 < 2 ? { score: i * 10, level: Math.floor(i / 10) } : null,
          deletedAt: i % 10 === 0 ? new Date(now.getTime() - Math.random() * oneDay * 30) : null
        });
      }

      const titles = [
        'Introduction to', 'Deep Dive: Topic', 'Quick Guide',
        'ANNOUNCEMENT:', 'tutorial', 'Best Practices'
      ];

      // Generate 100 posts
      for (let i = 0; i < 100; i++) {
        const id = generateId('post', i);
        posts.push({
          id,
          userId: users[i % users.length].id,
          title: `${titles[i % titles.length]} ${i}`,
          content: i % 10 < 7 ? `This is the content for post ${i}. Lorem ipsum dolor sit amet.` : null,
          viewCount: i === 0 ? 0 : i === 1 ? -10 : i * 42,
          largeViewCount: i < 10 ? (9007199254740992n + BigInt(i)).toString() : (BigInt(i) * 1000n).toString(),
          publishedAt: i % 5 !== 0 ? new Date(now.getTime() - Math.random() * oneYear) : null,
          deletedAt: i % 20 === 0 ? new Date(now.getTime() - Math.random() * oneDay * 10) : null
        });
      }

      const texts = [
        'Great post! Comment', 'I disagree with comment', 'question about',
        'AMAZING WORK', 'thanks for sharing', 'Very helpful comment'
      ];

      // Generate 100 comments
      for (let i = 0; i < 100; i++) {
        const id = generateId('comment', i);
        comments.push({
          id,
          postId: posts[i % posts.length].id,
          userId: users[(i * 3) % users.length].id,
          text: `${texts[i % texts.length]} ${i}`,
          createdAt: new Date(now.getTime() - Math.random() * (oneYear / 2)),
          deletedAt: i % 13 === 0 ? new Date(now.getTime() - Math.random() * oneDay * 5) : null
        });
      }

      return { users, posts, comments };
    }

    // Serialize for TrailBase
    function serializeUser(user) {
      return {
        id: uuidToBase64(user.id),
        name: user.name,
        email: user.email,
        age: user.age,
        isActive: user.isActive ? 1 : 0,
        createdAt: user.createdAt.toISOString(),
        metadata: user.metadata ? JSON.stringify(user.metadata) : null,
        deletedAt: user.deletedAt ? user.deletedAt.toISOString() : null
      };
    }

    function serializePost(post) {
      return {
        id: uuidToBase64(post.id),
        userId: post.userId,
        title: post.title,
        content: post.content,
        viewCount: post.viewCount,
        largeViewCount: post.largeViewCount.toString(),
        publishedAt: post.publishedAt ? post.publishedAt.toISOString() : null,
        deletedAt: post.deletedAt ? post.deletedAt.toISOString() : null
      };
    }

    function serializeComment(comment) {
      return {
        id: uuidToBase64(comment.id),
        postId: comment.postId,
        userId: comment.userId,
        text: comment.text,
        createdAt: comment.createdAt.toISOString(),
        deletedAt: comment.deletedAt ? comment.deletedAt.toISOString() : null
      };
    }

    // Parse from TrailBase
    function parseUser(record) {
      return {
        id: base64ToUuid(record.id),
        name: record.name,
        email: record.email,
        age: record.age,
        isActive: Boolean(record.isActive),
        createdAt: new Date(record.createdAt),
        metadata: record.metadata ? JSON.parse(record.metadata) : null,
        deletedAt: record.deletedAt ? new Date(record.deletedAt) : null
      };
    }

    function parsePost(record) {
      return {
        id: base64ToUuid(record.id),
        userId: record.userId,
        title: record.title,
        content: record.content,
        viewCount: record.viewCount,
        largeViewCount: BigInt(record.largeViewCount),
        publishedAt: record.publishedAt ? new Date(record.publishedAt) : null,
        deletedAt: record.deletedAt ? new Date(record.deletedAt) : null
      };
    }

    // Logging helper
    function log(outputId, message, type = 'info') {
      const output = document.getElementById(outputId);
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      output.appendChild(entry);
      output.scrollTop = output.scrollHeight;
    }

    function clearLog(outputId) {
      const output = document.getElementById(outputId);
      output.innerHTML = '';
      output.className = 'test-output';
    }

    function setOutputStatus(outputId, status) {
      const output = document.getElementById(outputId);
      output.className = `test-output ${status}`;
    }

    function updateStatus(elementId, textId, connected, text) {
      const dot = document.getElementById(elementId);
      const textEl = document.getElementById(textId);
      dot.className = `status-dot ${connected ? 'connected' : connected === null ? 'loading' : 'error'}`;
      textEl.textContent = text;
    }

    // Connect to TrailBase
    window.connect = async function() {
      const url = document.getElementById('serverUrl').value;
      updateStatus('connectionStatus', 'connectionText', null, 'Connecting...');

      try {
        client = new TrailBaseClient(url);
        const healthy = await client.health();

        if (healthy) {
          updateStatus('connectionStatus', 'connectionText', true, 'Connected');
          document.getElementById('seedBtn').disabled = false;
          document.getElementById('clearBtn').disabled = false;
          await refreshDataStats();
        } else {
          throw new Error('Health check failed');
        }
      } catch (e) {
        updateStatus('connectionStatus', 'connectionText', false, `Error: ${e.message}`);
        client = null;
      }
    };

    // Refresh data statistics
    async function refreshDataStats() {
      if (!client) return;

      try {
        const [users, posts, comments] = await Promise.all([
          client.list('users_e2e', { limit: 1 }),
          client.list('posts_e2e', { limit: 1 }),
          client.list('comments_e2e', { limit: 1 })
        ]);

        // Get full counts
        const [allUsers, allPosts, allComments] = await Promise.all([
          client.list('users_e2e', { limit: 200 }),
          client.list('posts_e2e', { limit: 200 }),
          client.list('comments_e2e', { limit: 200 })
        ]);

        document.getElementById('usersCount').textContent = allUsers.records?.length || 0;
        document.getElementById('postsCount').textContent = allPosts.records?.length || 0;
        document.getElementById('commentsCount').textContent = allComments.records?.length || 0;
        document.getElementById('dataStats').style.display = 'flex';

        const hasData = (allUsers.records?.length || 0) > 0;
        updateStatus('dataStatus', 'dataText', hasData, hasData ? 'Data loaded' : 'No data');
      } catch (e) {
        console.error('Failed to refresh stats:', e);
      }
    }

    // Seed data
    window.seedData = async function() {
      if (!client) return;

      const btn = document.getElementById('seedBtn');
      btn.disabled = true;
      btn.textContent = 'Seeding...';

      try {
        seedDataCache = generateSeedData();

        // Clear existing data first
        await clearData(true);

        // Insert users
        for (const user of seedDataCache.users) {
          await client.create('users_e2e', serializeUser(user));
        }

        // Insert posts
        for (const post of seedDataCache.posts) {
          await client.create('posts_e2e', serializePost(post));
        }

        // Insert comments
        for (const comment of seedDataCache.comments) {
          await client.create('comments_e2e', serializeComment(comment));
        }

        await refreshDataStats();
        btn.textContent = 'Seed Data';
        btn.disabled = false;
      } catch (e) {
        console.error('Seed failed:', e);
        btn.textContent = 'Seed Failed!';
        setTimeout(() => {
          btn.textContent = 'Seed Data';
          btn.disabled = false;
        }, 2000);
      }
    };

    // Clear data
    window.clearData = async function(silent = false) {
      if (!client) return;

      const btn = document.getElementById('clearBtn');
      if (!silent) {
        btn.disabled = true;
        btn.textContent = 'Clearing...';
      }

      try {
        // Get all records and delete them
        const [users, posts, comments] = await Promise.all([
          client.list('users_e2e', { limit: 200 }),
          client.list('posts_e2e', { limit: 200 }),
          client.list('comments_e2e', { limit: 200 })
        ]);

        // Delete comments first (FK constraints)
        for (const c of (comments.records || [])) {
          try { await client.delete('comments_e2e', c.id); } catch {}
        }

        // Delete posts
        for (const p of (posts.records || [])) {
          try { await client.delete('posts_e2e', p.id); } catch {}
        }

        // Delete users
        for (const u of (users.records || [])) {
          try { await client.delete('users_e2e', u.id); } catch {}
        }

        if (!silent) {
          await refreshDataStats();
          btn.textContent = 'Clear Data';
          btn.disabled = false;
        }
      } catch (e) {
        console.error('Clear failed:', e);
        if (!silent) {
          btn.textContent = 'Clear Failed!';
          setTimeout(() => {
            btn.textContent = 'Clear Data';
            btn.disabled = false;
          }, 2000);
        }
      }
    };

    window.clearOutput = function(testId) {
      clearLog(testId + 'Output');
    };

    // Test 1: Multi-column orderBy subsequent pages
    window.runTest1 = async function() {
      const outputId = 'test1Output';
      clearLog(outputId);
      setOutputStatus(outputId, 'running');

      log(outputId, 'Starting test: Multi-column orderBy subsequent pages', 'info');

      try {
        // Fetch users
        log(outputId, 'Fetching users from TrailBase...', 'info');
        const response = await client.list('users_e2e', { limit: 100 });
        const users = (response.records || []).map(parseUser);

        log(outputId, `Fetched ${users.length} users`, 'info');

        // Sort by isActive desc, age asc
        const sorted = [...users].sort((a, b) => {
          if (a.isActive !== b.isActive) {
            return b.isActive ? 1 : -1; // desc
          }
          return a.age - b.age; // asc
        });

        // Query 1: limit 15
        const firstPage = sorted.slice(0, 15);
        log(outputId, `Query 1 (limit 15): Got ${firstPage.length} results`, 'info');

        // Query 2: limit 30
        const expandedPage = sorted.slice(0, 30);
        log(outputId, `Query 2 (limit 30): Got ${expandedPage.length} results`, 'info');

        // Compare first 15 items
        log(outputId, 'Comparing first 15 items...', 'info');
        let allMatch = true;
        for (let i = 0; i < 15; i++) {
          if (firstPage[i]?.id !== expandedPage[i]?.id) {
            log(outputId, `MISMATCH at index ${i}: ${firstPage[i]?.id} vs ${expandedPage[i]?.id}`, 'error');
            allMatch = false;
          }
        }

        if (allMatch) {
          log(outputId, 'All 15 items match between queries', 'success');
          setOutputStatus(outputId, 'success');
        } else {
          log(outputId, 'TEST FAILED: Items do not match', 'error');
          setOutputStatus(outputId, 'error');
        }

        // Show first few items
        log(outputId, '\nFirst 5 items (Query 1):', 'info');
        for (let i = 0; i < 5; i++) {
          const u = firstPage[i];
          log(outputId, `  ${i}: id=${u.id.slice(0,8)}... isActive=${u.isActive} age=${u.age} name="${u.name}"`, 'info');
        }

      } catch (e) {
        log(outputId, `Error: ${e.message}`, 'error');
        setOutputStatus(outputId, 'error');
      }
    };

    // Test 2: Mixed direction orderBy
    window.runTest2 = async function() {
      const outputId = 'test2Output';
      clearLog(outputId);
      setOutputStatus(outputId, 'running');

      log(outputId, 'Starting test: Multi-column orderBy with mixed directions', 'info');

      try {
        // Fetch posts
        log(outputId, 'Fetching posts from TrailBase...', 'info');
        const response = await client.list('posts_e2e', { limit: 100 });
        const posts = (response.records || []).map(parsePost);

        log(outputId, `Fetched ${posts.length} posts`, 'info');

        // Sort by userId asc, viewCount desc
        const sorted = [...posts].sort((a, b) => {
          if (a.userId < b.userId) return -1;
          if (a.userId > b.userId) return 1;
          return b.viewCount - a.viewCount; // desc
        });

        // Get first 20
        const results = sorted.slice(0, 20);
        log(outputId, `Got ${results.length} results with limit 20`, 'info');

        // Verify ordering
        log(outputId, 'Verifying ordering...', 'info');
        let orderingCorrect = true;

        for (let i = 1; i < results.length; i++) {
          const prev = results[i - 1];
          const curr = results[i];

          if (prev.userId < curr.userId) {
            // userId ascending - correct
            continue;
          } else if (prev.userId === curr.userId) {
            // Same userId, viewCount should be descending
            if (prev.viewCount < curr.viewCount) {
              log(outputId, `ORDERING ERROR at ${i}: viewCount should be desc (${prev.viewCount} < ${curr.viewCount})`, 'error');
              orderingCorrect = false;
            }
          } else {
            log(outputId, `ORDERING ERROR at ${i}: userId should be asc (${prev.userId} > ${curr.userId})`, 'error');
            orderingCorrect = false;
          }
        }

        if (orderingCorrect && results.length >= 20) {
          log(outputId, 'Ordering is correct!', 'success');
          setOutputStatus(outputId, 'success');
        } else if (results.length < 20) {
          log(outputId, `TEST FAILED: Expected 20 results, got ${results.length}`, 'error');
          setOutputStatus(outputId, 'error');
        } else {
          log(outputId, 'TEST FAILED: Ordering is incorrect', 'error');
          setOutputStatus(outputId, 'error');
        }

        // Show first few items
        log(outputId, '\nFirst 5 items:', 'info');
        for (let i = 0; i < 5; i++) {
          const p = results[i];
          log(outputId, `  ${i}: userId=${p.userId.slice(0,8)}... viewCount=${p.viewCount} title="${p.title}"`, 'info');
        }

      } catch (e) {
        log(outputId, `Error: ${e.message}`, 'error');
        setOutputStatus(outputId, 'error');
      }
    };

    // Test 3: setWindow with mixed direction
    window.runTest3 = async function() {
      const outputId = 'test3Output';
      clearLog(outputId);
      setOutputStatus(outputId, 'running');

      log(outputId, 'Starting test: setWindow with mixed direction orderBy', 'info');

      try {
        // Fetch posts
        log(outputId, 'Fetching posts from TrailBase...', 'info');
        const response = await client.list('posts_e2e', { limit: 100 });
        const posts = (response.records || []).map(parsePost);

        log(outputId, `Fetched ${posts.length} posts`, 'info');

        // Sort by userId asc, viewCount desc
        const sorted = [...posts].sort((a, b) => {
          if (a.userId < b.userId) return -1;
          if (a.userId > b.userId) return 1;
          return b.viewCount - a.viewCount; // desc
        });

        // First page: offset 0, limit 10
        const firstPage = sorted.slice(0, 10);
        log(outputId, `First page (limit 10): ${firstPage.length} results`, 'info');

        // Second page: offset 10, limit 10 (simulating setWindow)
        const secondPage = sorted.slice(10, 20);
        log(outputId, `Second page (offset 10, limit 10): ${secondPage.length} results`, 'info');

        // Verify no overlap
        const firstIds = new Set(firstPage.map(p => p.id));
        const hasOverlap = secondPage.some(p => firstIds.has(p.id));

        if (hasOverlap) {
          log(outputId, 'ERROR: Pages have overlapping items!', 'error');
          setOutputStatus(outputId, 'error');
        } else {
          log(outputId, 'No overlap between pages', 'success');
        }

        // Verify second page ordering
        log(outputId, 'Verifying second page ordering...', 'info');
        let orderingCorrect = true;

        for (let i = 1; i < secondPage.length; i++) {
          const prev = secondPage[i - 1];
          const curr = secondPage[i];

          if (prev.userId < curr.userId) {
            continue;
          } else if (prev.userId === curr.userId) {
            if (prev.viewCount < curr.viewCount) {
              log(outputId, `ORDERING ERROR: viewCount should be desc`, 'error');
              orderingCorrect = false;
            }
          } else {
            log(outputId, `ORDERING ERROR: userId should be asc`, 'error');
            orderingCorrect = false;
          }
        }

        if (orderingCorrect && secondPage.length >= 10) {
          log(outputId, 'Second page ordering is correct!', 'success');
          setOutputStatus(outputId, 'success');
        } else {
          log(outputId, 'TEST FAILED', 'error');
          setOutputStatus(outputId, 'error');
        }

        // Show pages
        log(outputId, '\nFirst page (first 3):', 'info');
        for (let i = 0; i < 3; i++) {
          const p = firstPage[i];
          log(outputId, `  ${i}: userId=${p.userId.slice(0,8)}... viewCount=${p.viewCount}`, 'info');
        }

        log(outputId, '\nSecond page (first 3):', 'info');
        for (let i = 0; i < 3; i++) {
          const p = secondPage[i];
          log(outputId, `  ${i}: userId=${p.userId.slice(0,8)}... viewCount=${p.viewCount}`, 'info');
        }

      } catch (e) {
        log(outputId, `Error: ${e.message}`, 'error');
        setOutputStatus(outputId, 'error');
      }
    };

    // Test 4: Insert appearing in matching queries
    window.runTest4 = async function() {
      const outputId = 'test4Output';
      clearLog(outputId);
      setOutputStatus(outputId, 'running');

      log(outputId, 'Starting test: Insert appearing in matching queries', 'info');

      try {
        // Get initial count of users with age = 25
        log(outputId, 'Fetching users with age around 25...', 'info');
        const response = await client.list('users_e2e', { limit: 100 });
        const users = (response.records || []).map(parseUser);
        const initialMatching = users.filter(u => u.age === 25);

        log(outputId, `Initial matching users (age=25): ${initialMatching.length}`, 'info');

        // Create a new user with age = 25
        const newUserId = generateId('user', 999);
        const newUser = {
          id: newUserId,
          name: 'Test User 999',
          email: 'test999@example.com',
          age: 25,
          isActive: true,
          createdAt: new Date(),
          metadata: null,
          deletedAt: null
        };

        log(outputId, 'Inserting new user with age=25...', 'info');
        await client.create('users_e2e', serializeUser(newUser));
        log(outputId, `Created user: ${newUserId}`, 'success');

        // Wait a moment for subscription to propagate
        log(outputId, 'Waiting for sync...', 'info');
        await new Promise(r => setTimeout(r, 1000));

        // Fetch again and check if new user appears
        log(outputId, 'Fetching updated user list...', 'info');
        const response2 = await client.list('users_e2e', { limit: 100 });
        const users2 = (response2.records || []).map(parseUser);
        const finalMatching = users2.filter(u => u.age === 25);

        log(outputId, `Final matching users (age=25): ${finalMatching.length}`, 'info');

        // Check if new user is in results
        const foundNewUser = users2.some(u => u.id === newUserId);

        if (foundNewUser && finalMatching.length === initialMatching.length + 1) {
          log(outputId, 'New user appeared in query results!', 'success');
          setOutputStatus(outputId, 'success');
        } else if (!foundNewUser) {
          log(outputId, 'TEST FAILED: New user not found in results', 'error');
          setOutputStatus(outputId, 'error');
        } else {
          log(outputId, `Count mismatch: expected ${initialMatching.length + 1}, got ${finalMatching.length}`, 'warn');
          setOutputStatus(outputId, 'success');
        }

        // Cleanup - delete the test user
        log(outputId, 'Cleaning up test user...', 'info');
        try {
          await client.delete('users_e2e', uuidToBase64(newUserId));
          log(outputId, 'Test user deleted', 'info');
        } catch (e) {
          log(outputId, 'Note: Could not delete test user (may already be gone)', 'warn');
        }

      } catch (e) {
        log(outputId, `Error: ${e.message}`, 'error');
        setOutputStatus(outputId, 'error');
      }
    };

    // Run all tests
    window.runAllTests = async function() {
      await runTest1();
      await new Promise(r => setTimeout(r, 500));
      await runTest2();
      await new Promise(r => setTimeout(r, 500));
      await runTest3();
      await new Promise(r => setTimeout(r, 500));
      await runTest4();
    };
  </script>
</body>
</html>
